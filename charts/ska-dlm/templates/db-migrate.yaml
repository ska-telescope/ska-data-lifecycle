{{- if and .Values.database.migration.enabled .Values.database.migration.base.baseInstall .Values.database.migration.patch.patchInstall }}
{{- fail "You cannot enable both baseInstall and patchInstall simultaneously." }}
{{- end }}

{{- if and .Values.database.migration.enabled .Values.database.migration.base.baseInstall }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "ska-dlm.fullname" . }}-base-migration
spec:
  template:
    spec:
      containers:
      - name: base-migration
        image: {{ .Values.database.migration.image }}:{{ .Values.database.migration.version }}
        command: ["/bin/sh", "-c"]
        args:
          - |
            echo "Waiting for Postgres to be ready...";
            attempts=0
            max_attempts=30
            until pg_isready -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE"; do
              attempts=$((attempts + 1))
              if [ "$attempts" -ge "$max_attempts" ]; then
                echo "Postgres not ready after $((max_attempts * 2)) seconds, exiting."
                exit 1
              fi
              sleep 2;
            done;

            # Create DB if it does not exist
            if ! psql -tc "SELECT 1 FROM pg_database WHERE datname = '${PGDATABASE}'" | grep -q 1; then
              createdb --encoding=UTF8 --locale=en_US.utf8 --template=template0 "$PGDATABASE"
            fi

            {{- if not .Values.postgrest.db_schema }}
            echo "WARNING: No postgrest.db_schema provided, defaulting to 'public'";
            {{- end }}

            echo "Target database (env var): $PGDATABASE"
            echo "Target schema  (env var): ${PGOPTIONS#*-c search_path=}"
            psql -tA -c "SELECT 'Target database (Postgres): ' || current_database();"
            psql -tA -c "SELECT 'Target schema  (Postgres): ' || array_to_string(current_schemas(false), ',');"

            if ls /etc/sql/base/*.sql 1> /dev/null 2>&1; then
              for f in /etc/sql/base/*.sql; do
                echo "Running $f"
                psql -v ON_ERROR_STOP=1 -f "$f" 2>&1 || exit 1
              done
            else
              echo "No base files found"
            fi
        env:
        {{- range $envvar_name := tuple "PGUSER" "PGPASSWORD" "PGHOST" "PGDATABASE" }}
        - name: {{ $envvar_name }}
          valueFrom:
            secretKeyRef:
              name: {{ include "ska-dlm.postgrest.db-auth-secret-name" $ }}
              key: {{ $envvar_name }}
        {{- end }}
        - name: PGPORT
          valueFrom:
            secretKeyRef:
              name: {{ include "ska-dlm.postgrest.db-auth-secret-name" $ }}
              key: PGPORT
              optional: true
        - name: PGOPTIONS
          value: >-
            -c search_path={{- if .Values.postgrest.db_schema }}{{ .Values.postgrest.db_schema }},public{{- else }}public{{- end }}
        volumeMounts:
        - name: base-volume
          mountPath: /etc/sql/base/
      volumes:
      - name: base-volume
        configMap:
          name: ska-dlm-postgresql-initdb-base-scripts
      restartPolicy: Never
  backoffLimit: 1
{{- end }}

---

{{- if and .Values.database.migration.enabled .Values.database.migration.patch.patchInstall }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "ska-dlm.fullname" . }}-patch-migration-{{ .Values.database.migration.patch.patchVersion | replace "." "-" }}
spec:
  template:
    spec:
      containers:
      - name: patch-migration
        image: {{ .Values.database.migration.image }}:{{ .Values.database.migration.version }}
        command: ["/bin/sh", "-c"]
        args:
          - |
            echo "Waiting for Postgres to be ready...";
            attempts=0
            max_attempts=30
            until pg_isready -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE"; do
              attempts=$((attempts + 1))
              if [ "$attempts" -ge "$max_attempts" ]; then
                echo "Postgres not ready after $((max_attempts * 2)) seconds, exiting."
                exit 1
              fi
              sleep 2;
            done;

            {{- if not .Values.postgrest.db_schema }}
            echo "WARNING: No postgrest.db_schema provided, defaulting to 'public'";
            {{- end }}

            echo "Target database (env var): $PGDATABASE"
            echo "Target schema  (env var): ${PGOPTIONS#*-c search_path=}"
            psql -tA -c "SELECT 'Target database (Postgres): ' || current_database();"
            psql -tA -c "SELECT 'Target schema  (Postgres): ' || array_to_string(current_schemas(false), ',');"

            echo "Looking for patch files in /etc/sql/patch/";
            if ls /etc/sql/patch/*.sql 1> /dev/null 2>&1; then
              for f in /etc/sql/patch/*.sql; do
                echo "Running $f";
                psql -v ON_ERROR_STOP=1 -f "$f" 2>&1 || exit 1
              done;
              echo "Please check the logs in Postgres pod for any warnings.";
            else
              echo "No patch files found";
            fi
        env:
        {{- range $envvar_name := tuple "PGUSER" "PGPASSWORD" "PGHOST" "PGDATABASE" }}
        - name: {{ $envvar_name }}
          valueFrom:
            secretKeyRef:
              name: {{ include "ska-dlm.postgrest.db-auth-secret-name" $ }}
              key: {{ $envvar_name }}
        {{- end }}
        - name: PGPORT
          valueFrom:
            secretKeyRef:
              name: {{ include "ska-dlm.postgrest.db-auth-secret-name" $ }}
              key: PGPORT
              optional: true
        - name: PGOPTIONS
          value: >-
            -c search_path={{- if .Values.postgrest.db_schema }}{{ .Values.postgrest.db_schema }},public{{- else }}public{{- end }}
        volumeMounts:
        - name: patch-volume
          mountPath: /etc/sql/patch/
      volumes:
      - name: patch-volume
        configMap:
          name: {{ include "ska-dlm.fullname" . }}-patch-migration-{{ .Values.database.migration.patch.patchVersion | replace "." "-" }}
      restartPolicy: Never
  backoffLimit: 1
{{- end }}
